Міністерство освіти та науки України
Харківський національний університет радіоелектроніки




Кафедра програмної інженерії




ЗВІТ
з практичної роботи №1
з дисципліни «Скриптові мови програмування»
на тему: «Розробка Bash-скрипта»












Виконала        Перевірив: 
ст. гр. ПЗПІ-23-3        ст. викл. каф. ПІ
Коваленко В.О.        Сокорчук І.П.


















Харків, 2025 р.
1 ІСТОРІЯ ЗМІН
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	20.04.2025
	       0.1
	Додано розділ “Завдання”
	2
	22.04.2025
	28.  0.2
	Додано розділ “Опис виконаної роботи” та підрозділ “Хід роботи”
	3
	25.04.2025
	2.1  0.3
	Додано підрозділ “Тестування скрипта”
	4
	28.04.2025
	12.10.4
	Додано розділ “Висновки”
	5
	01.05.2025
	10.10.5
	Додано “Додаток А”, “Додаток Б”, “Додаток В”
	________________


2 ЗАВДАННЯ
2.1 Постановка завдання
Необхідно написати Bash скрипт, який друкуватиме на екрані ялинку із двох ярусів гілок, стовбура та шару снігу. Висота та ширина ялинки передаються як аргументи командного рядка. 
2.2 Вимоги відображення ялинки
Ялинка повинна відповідати наступним вимогам:
* Ялинка повинна бути симетричною.
* Яруси гілок мають утворювати правильні рівнобедрені трикутники, у яких сусідні рядки відрізняються на два символи та складаються почергово з символів «*» або «#».
* Ширина всіх ярусів гілок повинна бути на 2 символи вужча, ніж ширина снігу.
* Висота стовбура та товщина снігу мають бути такими, як у прикладі.
* Параметри скрипта повинні мати додатнє значення.
* Вказані значення округлюються до потрібних у меншу сторону.
* Якщо за заданими параметрами неможливо зобразити ялинку на екрані, скрипт має вивести повідомлення про помилкове значення аргумента у потік помилок і повернути відповідний код у батьківський процес.
* Ялинка повинна бути виведена у командний рядок з використанням циклів, умовних операторів та функції:   if … then … fi; while … do … done; until … do … done; for … in .. do … done; for ((…)); do … done
2.3 Вимоги створення та написання скрипта
Вихідний скрипт повинен відповідати наступним вимогам:
* Право редагувати файл скрипта повинен мати лише власник скрипта.
* Скрипт повинен бути доступним для виконання для всіх користувачів.
________________


3 ОПИС ВИКОНАНОЇ РОБОТИ 
3.1 Хід роботи
        У ході виконання практичного завдання будемо покроково створювати скрипт, прописувати необхуднфі функції та тестувати результат виконання 
3.1.1 Створення Bash-скрипта
Для виконання практичного завдання №1 знадобиться відповідний файл скрипта, де будуть прописані всі необхідні команди та функції для успішного відображення ялинки на консолі. Отже, використовуючи  touch в командному рядку прописуємо наступну команду:
touch pzpi-23-3-kovalenko-violetta-task1
3.1.2 Налаштування прав доступу скрипта
За умовами завдання скрипт повинен бути доступним для виконання для всіх користувачів, а  право редагувати файл скрипта повинен мати лише власник скрипта. Тому прописуємо наступні команди в командний рядок
chmod 755 pzpi-23-3-kovalenko-violetta-task1
chmod +x pzpi-23-3-kovalenko-violetta-task1
3.1.3 Створення головної функції
Оскільки скрипт буде складатися з багатьох функцій та команд, які разом малюють симетричну ялинку з двома ярусами гілок, стовбуром і шаром снігу, то необхідно створити основну(головну) функцію, яка буде контролювати весь процес виконання скрипта, та викликати необхідні допоміжні функції. Для цього була створена функція draw_tree (див. додаток В, В1), яка  приймає параметри висоти і ширини ялинки, перевіряє їх коректність за допомогою допоміжної функції is_parameters_valid (див. додаток В, В1, ряд. 19), потім розраховує висоти верхнього та нижнього ярусів гілок через calculate_top_lower_layers_height, а також максимальну ширину ярусів за допомогою формули $((1 + 2 * (top_layer - 1))) (див. додаток В, В1, ряд. 36). Далі draw_tree викликає допоміжну функцію draw_top_lower_layers(див. додаток В, В1 ряд. 38), яка малює рівнобедрені трикутники верхнього і нижнього ярусів гілок, чергуючи символи * і # та центровані по ширині. Після цього малюється стовбур функцією draw_pillar(див. додаток В, В1 ряд. 39), яка виводить два рядки шириною три символи #, центровані під кроною. В кінці додається сніговий шар за допомогою draw_snow_layer(див. додаток В, В1 ряд. 40), що виводить рядок із символів * шириною на два символи більшу за ширину крони.
3.1.4 Створення допоміжної функції для перевірки на валідність вхідних параметрів скрипта
Функція is_parameters_valid(див. додаток В, В2) відповідає за перевірку коректності вхідних параметрів скрипта, зокрема висоти та ширини ялинки, та їх відповідність встановленим вимогам. Спочатку вона переконується, що висота не менша за 8, а ширина не менша за 7 символів, адже це мінімальні значення для відображення ялинки(див. додаток В, В2 ряд. 49 - 57). Далі функція за потреби коригує висоту та ширину(див. додаток В, В2 ряд. 61 - 69). Потім перевіряє, чи сумарна висота верхнього та нижнього ярусів гілок співпадає з шириною мінус два символи, що гарантує правильні пропорції крони(див. додаток В, В2 ряд. 71 - 73). Також переконується, що кожен ярус має мінімальну висоту не менше двох рядків(див. додаток В, В2 ряд. 78 - 80). Якщо будь-яке з цих умов не виконується, функція повертає код помилки, сигналізуючи про некоректність параметрів.
3.1.5 Створення функції для відображення верхнього і нижнього ярусів гілок ялинки на консолі.
Для графічного відображення ялинки на консолі була створена функція draw_top_lower_layers(див. додаток В, В3), яка приймає три аргументи: висоту верхнього ярусу, висоту нижнього ярусу та максимальну ширину ярусів. Вона по черзі виводить рядки верхнього ярусу, де ширина рядка збільшується від 1 символа з кроком 2. Символи в рядках чергуються: у парних рядках — *, у непарних — #(див. додаток В, В3 ряд. 100 - 104). Кожен рядок центрований відносно максимальної ширини. Після верхнього ярусу визначається початковий символ для нижнього ярусу — протилежний останньому символу верхнього ярусу(див. додаток В, В3 ряд. 112 - 117). Нижній ярус виводиться аналогічно, але мінімальна ширина рядка — 3 символи. В результаті формується два рівнобедрених трикутники, що разом утворюють крону ялинки.
3.1.6 Створення функції для відображення стовбуру ялинки на консолі.
Для графічного відображення  стовбуру ялинки на консолі була створена функція draw_pillar(див. додаток В, В4), яка приймає один аргумент — максимальну ширину ярусів крони. Вона малює стовбур ялинки у вигляді двох рядків, кожен шириною 3 символи #.  Для центрованого розміщення стовбура обчислює кількість пробілів зліва як половину різниці між максимальною шириною і шириною стовбура. Кожен рядок складається з відповідної кількості пробілів і трьох символів #. 
3.1.7 Створення функції для відображення нижнього шару снігу на консолі.
Для графічного відображення   нижнього шару снігу на консолі була створена функція draw_pillar(див. додаток В, В5), яка приймає один аргумент — максимальну ширину ярусів крони. Вона обчислює ширину снігового шару як max_width_of_layers + 2(див. додаток В, В5, ряд. 157). Потім у циклі виводить рядок із символів * довжиною, рівною цій ширині(див. додаток В, В5, ряд. 160-163). Таким чином утворюється снігова підставка ширше крони, яка виводиться під стовбуром і ярусами ялинки.
3.2 Тестування скрипта 
Після завершення написання скрипта необхідно протестувати протестувати цей скрипт. Якщо введені значення параметрів валідні — скрипт успішно намалює ялинку відповідно до заданих розмірів і правил. Наприклад, введемо наступну команду виклику скрипта у командний рядок:
./pzpi-23-3-kovalenko-violetta-task1.sh 18 18
Ми отримали правильно намальовану ялинку, роздруковану на консолі (див. додаток Б, Рисунок Б.1). Якщо ж значення некоректні або не відповідають вимогам, скрипт виведе повідомлення про помилку та припинить роботу. Наприклад, введемо наступну команду виклику скрипта у командний рядок:
./pzpi-23-3-kovalenko-violetta-task1.sh 5 10. 
Ми отримали помилку про те, що висота повинна бути хоча б 8, отже введені користувачем дані є невалідними, а розроблений скрипт правильно обробляє та виводить помилки на консоль
________________


4 ВИСНОВКИ
В процесі виконання завдання був створений Bash-скрипт, який малює ялинку у командному рядку відповідно до встановлених вимог. Скрипт включає перевірку вхідних параметрів, обробку помилок, форматування виводу, а також малювання гілок, стовбура і снігового шару за допомогою різних циклів, умовних конструкцій та власних функцій. Тестування показало, що програма коректно працює як з валідними, так і з невалідними даними. Усі поставлені умови виконано, скрипт функціонує відповідно до заданих вимог
________________


ДОДАТОК А
Відеозапис
Відеозапис презентації результатів лабораторної роботи: https://youtu.be/r5ohyvAr-5U
Хронологічний опис відеозапису:
00:00 –  Представлення
00:23 – Запуск скрипта
00:43 – Початок пояснення коду
00:45 – Визначення необхідних констант
01:03 – Визначення необхідних змінних-прапорів
01:23 – Визначення головної функції draw_tree
03:42 – Визначення функції, яка перевіряє валідність параметрів is_parametrs_valid
06:00 – Визначення функції, яка відмальовує верхній та нижній шари ялинки draw_top_lower_layer
09:57 – Визначення функції, яка відмальовує стовбур ялинки
11:21 – Визначення функції, яка відмальовує нижній шар снігу
12:11 – Виклик головної функції з переданими користувачем параметрами
________________


ДОДАТОК Б
Графічні матеріали
  

Рисунок Б.1 — Результат виконання скрипта
________________


ДОДАТОК В
Програмний код
В.1 Головна функція, яка координує процес малювання ялинки
GitHub репозиторій: https://github.com/NureKovalenkoVioletta/smp-pzpi-23-3-kovalenko-violetta/blob/main/Pract1/smp-pzpi-23-3-kovalenko-violetta-pract1/smp-pzpi-23-3-kovalenko-violetta-pract1-code.sh
 11 draw_tree() {
 12
 13     local height=$1
 14     local width=$2
 15
 16     local top_layer=0
 17     local bottom_layer=0
 18
 19     is_parameters_valid "$height" "$width"
 20
 21     local is_valid=$?
 22
 23     if [[ $is_valid -ne 0 ]]; then
 24         echo "Error: Tree cannot be drawn with the specified height and width." >&2
 25         exit 1
 26     fi
 27
 28     if [[ $REDUCE_HEIGHT == "true" ]]; then
 29         ((height--))
 30     fi
 31
 32     if [[ $REDUCE_WIDTH == "true" ]]; then
 33         ((width--))
 34     fi
 35
 36     max_width_of_layers=$((1 + 2 * (top_layer - 1)))
 37
 38     draw_top_lower_layers "$top_layer" "$lower_layer" "$max_width_of_layers"
 39     draw_pillar "$max_width_of_layers"
 40     draw_snow_layer "$max_width_of_layers"
 41
 42 }


В.2 Допоміжна функція для перевірки на валідність вхідних параметрів скрипта
GitHub репозиторій: https://github.com/NureKovalenkoVioletta/smp-pzpi-23-3-kovalenko-violetta/blob/main/Pract1/smp-pzpi-23-3-kovalenko-violetta-pract1/smp-pzpi-23-3-kovalenko-violetta-pract1-code.sh
 44 is_parameters_valid() {
 45
 46     local height=$1
 47     local width=$2
 48
 49     if [[ $height -lt 8 ]]; then
 50         echo "Error: Height must be at least 8." >&2
 51         exit 1
 52     fi
 53
 54     if [[ $width -lt 7 ]]; then
 55         echo "Error: Width must be at least 7." >&2
 56         exit 1
 57     fi
 58
 59     local layer1_layer2=$((height - PILLAR_HEIGHT - BOTTOM_LAYER_OF_SNOW_HEIGHT))
 60
 61     if ((layer1_layer2 % 2 == 0)); then
 62         REDUCE_HEIGHT="true"
 63         ((layer1_layer2--))
 64     fi
 65
 66     if ((width % 2 == 0)); then
 67         REDUCE_WIDTH="true"
 68         ((width--))
 69     fi
 70
 71     if [[ $layer1_layer2 -ne $((width - 2)) ]]; then
 72         return 1
 73     fi
 74
 75     top_layer=$((layer1_layer2 / 2 + 1))
 76     lower_layer=$((layer1_layer2 - top_layer))
 77
 78     if [[ $top_layer -lt 2 || $lower_layer -lt 2 ]]; then
 79         return 1
 80     fi
 81
 82     return 0
 83 }


В.3 Функція для графічного відображення ярусів ялинки на консолі
GitHub репозиторій: https://github.{…}/{ файл_з_програмним_кодом }


 85 draw_top_lower_layers() {
 86     local top_layer_height=$1
 87     local lower_layer_height=$2
 88     local max_width_of_layers=$3
 89
 90     local min_width_for_top_layer=1
 91     local min_width_for_lower_layer=3
 92     local step=2
 93     local empty_space=1
 94     local last_symbol='*'
 95
 96     for ((i = 0; i < top_layer_height; i++)); do
 97         local stars=$((min_width_for_top_layer + i * step))
 98         local spaces=$(( (max_width_of_layers - stars) / 2 ))
 99         local symbol
100         if ((i % 2 == 0)); then
101             symbol="*"
102         else
103             symbol="#"
104         fi
105
106         printf "%*s%*s" $empty_space "" $spaces ""
107         printf "%${stars}s\n" | tr " " "$symbol"
108
109         last_symbol=$symbol
110     done
111
112     local first_lower_symbol
113     if [[ $last_symbol == "*" ]]; then
114         first_lower_symbol="#"
115     else
116         first_lower_symbol="*"
117     fi
118
119     for i in $(seq 0 $((lower_layer_height - 1))); do
120         local stars=$((min_width_for_lower_layer + i * step))
121         local spaces=$(( (max_width_of_layers - stars) / 2 ))
122         local symbol
123         if ((i % 2 == 0)); then
124             symbol=$first_lower_symbol
125         else
126             if [[ $first_lower_symbol == "*" ]]; then
127                 symbol="#"
128             else
129                 symbol="*"
130             fi
131         fi
132
133         printf "%*s%*s" $empty_space "" $spaces ""
134         printf "%${stars}s\n" | tr " " "$symbol"
135     done
136 }


В.4 Функція для графічного відображення стовбура на консолі
GitHub репозиторій: https://github.com/NureKovalenkoVioletta/smp-pzpi-23-3-kovalenko-violetta/blob/main/Pract1/smp-pzpi-23-3-kovalenko-violetta-pract1/smp-pzpi-23-3-kovalenko-violetta-pract1-code.sh
138 draw_pillar() {
139     local max_width_of_layers=$1
140     local pillar_width=3
141     local pillar_height=2
142     local pillar_spaces=$(( (max_width_of_layers - pillar_width) / 2 ))
143     local empty_space=1
144
145     i=0
146     while [ $i -lt $pillar_height ]; do
147         printf "%*s" $empty_space ""
148         printf "%*s" $pillar_spaces ""
149         printf "%${pillar_width}s\n" | tr " " "#"
150         ((i++))
151     done
152 }


В.5 Функція для графічного відображення нижнього шару снігу на консолі
GitHub репозиторій: https://github.com/NureKovalenkoVioletta/smp-pzpi-23-3-kovalenko-violetta/blob/main/Pract1/smp-pzpi-23-3-kovalenko-violetta-pract1/smp-pzpi-23-3-kovalenko-violetta-pract1-code.sh
155 draw_snow_layer() {
156     local max_width_of_layers=$1
157     local snow_width=$((max_width_of_layers + 2))
158
159     local i=0
160     until [ $i -ge $snow_width ]; do
161         printf "*"
162         ((i++))
163     done
164     echo
165 }